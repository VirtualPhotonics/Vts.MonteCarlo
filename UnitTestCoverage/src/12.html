<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Users\lisa\Documents\Projects\UCI\VTS_Release\Vts.MonteCarlo\Vts.MonteCarlo.CommandLineApplication\MonteCarloSetup.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Vts.Common;
using Vts.Common.Logging;
using Vts.Extensions;
using Vts.MonteCarlo.DataStructuresValidation;
using Vts.MonteCarlo.Extensions;
using Vts.MonteCarlo.IO;

namespace Vts.MonteCarlo.CommandLineApplication
{
    public static class MonteCarloSetup
    {
        private static readonly ILogger Logger = LoggerFactoryLocator.GetDefaultNLogFactory().Create(typeof(MonteCarloSetup));

        /// &lt;summary&gt;
        /// method to read the simulation input from a specified or default file
        /// &lt;/summary&gt;
        public static SimulationInput ReadSimulationInputFromFile(string inputFile)
        {
            try
            {
                if (string.IsNullOrEmpty(inputFile))
                {
                    Logger.Info(&quot; *** No input file specified ***\n\nDefine an input file using mc.exe infile=infile_name.txt&quot;);
                    return null;
                }

                //get the full path for the input file
                var fullFilePath = Path.GetFullPath(inputFile);

                if (File.Exists(fullFilePath))
                {
                    return SimulationInput.FromFile(fullFilePath);       
                }

                if (File.Exists(fullFilePath + &quot;.txt&quot;))
                {
                    return SimulationInput.FromFile(fullFilePath + &quot;.txt&quot;);
                }

                //throw a file not found exception
                throw new FileNotFoundException(&quot;\nThe following input file could not be found: &quot; + fullFilePath + &quot; - type mc help=infile for correct syntax&quot;);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                return null;
            }
        }

        public static ParameterSweep CreateParameterSweep(string[] parameterSweepString, ParameterSweepType type) // check for null returns?
        {
            if ((type == ParameterSweepType.Count || type == ParameterSweepType.Delta))
            {
                if (parameterSweepString.Length != 4)
                {
                    
                    var message =
                        &quot; *** Invalid sweep parameter ***&quot; +
                        &quot;\n\t\tsweep parameters should have 4 values in the format:&quot;;
                    if (type == ParameterSweepType.Delta)
                    {
                        message += &quot;\n\t\tparamsweepdelta=&lt;Parameter&gt;,Start,Stop,Delta&quot;;
                    }
                    else
                    {
                        message += &quot;\n\t\tparamsweep=&lt;Parameter&gt;,Start,Stop,Count&quot;;
                    }
                    message += &quot;\n\t\tIgnoring this sweep parameter\n&quot;;
                    Logger.Warn(() =&gt; message);
                    return null;
                    
                }
            }
            else // type==ParameterSweepType.List
            {
                var number = double.Parse(parameterSweepString[1]);
                // check that number is an integer and that number of parameters is 2 more than number
                if ((number == Math.Floor(number)) &amp;&amp; (parameterSweepString.Length != number + 2))
                {
                    var message =
                        &quot; *** Invalid sweep parameter: either Number or number of Vals is in error ***&quot; +
                        &quot;\n\t\tsweep parameters should have format paramsweeplist=&lt;Parameter&gt;,NumVals,Val1,...,ValN&quot;;
                    message += &quot;\n\t\tIgnoring this sweep parameter\n&quot;;
                    Logger.Warn(() =&gt; message);
                    return null;
                }
            }

            try
            {
                var inputParameterType = parameterSweepString[0];
                double start, stop;
                DoubleRange sweepRange;
                switch (type)
                {
                    // batch parameter values should come in fours for Delta and Count
                    case ParameterSweepType.Delta:
                        // eg. paramsweepdelta=mua1,0.0,4.0,0.05 paramsweepdelta=mus1,0.5,1.5,0.1 paramsweepdelta=mus2,0.5,1.5,0.1 ...
                        start = double.Parse(parameterSweepString[1]);
                        stop = double.Parse(parameterSweepString[2]);
                        var delta = double.Parse(parameterSweepString[3]);
                        // use Math.Round to make sure floating point precision doesn&#39;t reduce/increase count
                        sweepRange = new DoubleRange(start, stop, (int)(Math.Round((stop - start) / delta)) + 1);
                        return new ParameterSweep(inputParameterType, sweepRange);
                    case ParameterSweepType.Count: 
                        // eg. paramsweep=mua1,0.01,4.0,101 paramsweep=mus1,0.5,1.5,3 paramsweep=mus2,0.5,1.5,3 ...
                        start = double.Parse(parameterSweepString[1]);
                        stop = double.Parse(parameterSweepString[2]);
                        var count = int.Parse(parameterSweepString[3]);
                        sweepRange = new DoubleRange(start, stop, count);
                        return new ParameterSweep(inputParameterType, sweepRange);
                    case ParameterSweepType.List:
                        // eg. paramsweeplist=mua1,2,0.01,0.02
                        var number = int.Parse(parameterSweepString[1]);
                        var sweepList = new double[number];
                        for (var i = 0; i &lt; number; i++)
                        { 
                            sweepList[i]=double.Parse(parameterSweepString[i + 2]);
                        }
                        return new ParameterSweep(inputParameterType, sweepList);
                }
                return null;
            }
            catch
            {
                Logger.Error(() =&gt; &quot;Could not parse the input arguments.\n\tIgnoring the following input parameter sweep: &quot; + parameterSweepString);
                return null;
            }
        }

        public static IEnumerable&lt;SimulationInput&gt; ApplyParameterSweeps(SimulationInput input, IEnumerable&lt;ParameterSweep&gt; parameterSweeps)
        {
            var batchInputs = input.AsEnumerable();

            foreach (var parameterSweep in parameterSweeps)
            {
                var sweepValues = parameterSweep.Values.ToEnumerable&lt;double&gt;();

                batchInputs = batchInputs.WithParameterSweep(sweepValues, parameterSweep.Name.ToLower());
            }

            return batchInputs.ToArray();
        }

        public static ValidationResult ValidateSimulationInput(SimulationInput input)
        {
            return SimulationInputValidation.ValidateInput(input);
        }

        public static void RunSimulation(SimulationInput input, string outputFolderPath, int numberOfCPUs)
        {
            // locate root folder for output, creating it if necessary
            var path = string.IsNullOrEmpty(outputFolderPath)
                ? Path.GetFullPath(Directory.GetCurrentDirectory())
                : Path.GetFullPath(outputFolderPath);
            if (!Directory.Exists(path))
            {
                Directory.CreateDirectory(path);
            }

            // locate destination folder for output, creating it if necessary
            var resultsFolder = Path.Combine(path, input.OutputName);
            if (!Directory.Exists(resultsFolder))
            {
                Directory.CreateDirectory(resultsFolder);
            }
            SimulationOutput detectorResults;
            if (numberOfCPUs &gt; 1)
            {
                var parallelMC = new ParallelMonteCarloSimulation(input, numberOfCPUs);
                //parallelMC.SetOutputPathForDatabases(path); // no inheritance of MonteCarloSimulation class
                detectorResults = parallelMC.RunSingleInParallel();
            }
            else
            {
                var mc = new MonteCarloSimulation(input);
                mc.SetOutputPathForDatabases(path);
                detectorResults = mc.Run();
            }

            input.ToFile(Path.Combine(resultsFolder, input.OutputName + &quot;.txt&quot;));

            foreach (var result in detectorResults.ResultsDictionary.Values)
            {
                // save all detector data to the specified folder
                DetectorIO.WriteDetectorToFile(result, resultsFolder);
            }
        }

        /// &lt;summary&gt;
        /// Runs multiple Monte Carlo simulations in parallel using all available CPU cores
        /// &lt;/summary&gt;
        public static void RunSimulations(IEnumerable&lt;SimulationInput&gt; inputs, string outputFolderPath, int numberOfCPUs)
        {
            var options = new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount };
            Parallel.ForEach(inputs, options, (input, state, index) =&gt;
            {
                input.Options.SimulationIndex = (int)index;
                RunSimulation(input, outputFolderPath, numberOfCPUs);
            });
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,9,17,127,1],[23,9,23,10,1],[25,13,25,14,1],[26,17,26,53,1],[27,17,27,18,1],[28,21,28,129,1],[29,21,29,33,1],[33,17,33,64,1],[35,17,35,47,1],[36,17,36,18,1],[37,21,37,67,1],[40,17,40,56,1],[41,17,41,18,1],[42,21,42,76,1],[46,17,46,161,1],[48,13,48,32,1],[49,13,49,14,1],[50,17,50,46,1],[51,17,51,29,1],[53,9,53,10,1],[56,9,56,10,1],[57,13,57,88,1],[58,13,58,14,1],[59,17,59,54,1],[60,17,60,18,1],[62,21,64,86,1],[65,21,65,58,1],[66,21,66,22,1],[67,25,67,89,1],[68,21,68,22,1],[70,21,70,22,1],[71,25,71,84,1],[72,21,72,22,1],[73,21,73,72,1],[74,21,74,39,1],[74,39,74,46,1],[74,46,74,48,1],[75,21,75,33,1],[78,13,78,14,1],[80,13,80,14,1],[81,17,81,68,1],[83,17,83,99,1],[84,17,84,18,1],[85,21,87,118,1],[88,21,88,72,1],[89,21,89,39,1],[89,39,89,46,1],[89,46,89,48,1],[90,21,90,33,1],[92,13,92,14,1],[95,13,95,14,1],[96,17,96,66,1],[99,17,99,30,1],[104,25,104,71,1],[105,25,105,70,1],[106,25,106,75,1],[108,25,108,114,1],[109,25,109,83,1],[112,25,112,71,1],[113,25,113,70,1],[114,25,114,72,1],[115,25,115,74,1],[116,25,116,83,1],[119,25,119,73,1],[120,25,120,60,1],[121,30,121,39,1],[121,41,121,51,1],[121,53,121,56,1],[122,25,122,26,1],[123,29,123,84,1],[124,25,124,26,1],[125,25,125,82,1],[127,17,127,29,1],[129,13,129,18,1],[130,13,130,14,1],[131,17,131,36,1],[131,36,131,147,1],[131,147,131,149,1],[132,17,132,29,1],[134,9,134,10,1],[137,9,137,10,1],[138,13,138,52,1],[140,13,140,20,1],[140,22,140,40,1],[140,41,140,43,1],[140,44,140,59,1],[141,13,141,14,1],[142,17,142,80,1],[144,17,144,106,1],[145,13,145,14,1],[147,13,147,42,1],[148,9,148,10,1],[151,9,151,10,1],[152,13,152,67,1],[153,9,153,10,1],[156,9,156,10,1],[158,13,160,54,1],[161,13,161,41,1],[162,13,162,14,1],[163,17,163,49,1],[164,13,164,14,1],[167,13,167,70,1],[168,13,168,50,1],[169,13,169,14,1],[170,17,170,58,1],[171,13,171,14,1],[173,13,173,34,1],[174,13,174,14,1],[175,17,175,88,1],[177,17,177,68,1],[178,13,178,14,1],[180,13,180,14,1],[181,17,181,58,1],[182,17,182,52,1],[183,17,183,44,1],[184,13,184,14,1],[186,13,186,82,1],[188,13,188,20,1],[188,22,188,32,1],[188,33,188,35,1],[188,36,188,76,1],[189,13,189,14,1],[191,17,191,71,1],[192,13,192,14,1],[193,9,193,10,1],[199,9,199,10,1],[200,13,200,103,1],[201,13,202,13,1],[202,13,202,14,1],[202,14,203,17,1],[203,17,203,60,1],[203,60,204,17,1],[204,17,204,70,1],[204,70,205,13,1],[205,13,205,14,1],[205,14,205,16,1],[206,9,206,10,1]]);
    </script>
  </body>
</html>